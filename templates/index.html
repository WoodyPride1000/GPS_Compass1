<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8">
    <title>GPS可視化</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Leaflet CSS CDN -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" crossorigin="" />
    <!-- カスタムスタイルシート (styles.css は /static/ に配置を想定) -->
    <link rel="stylesheet" href="/static/styles.css" />
    <style>
        body {
            margin: 0;
            overflow: hidden; /* スクロールバーを非表示にする */
            font-family: 'Inter', sans-serif; /* Tailwind CSSのデフォルトフォント */
        }

        /* 地図コンテナのスタイル */
        #map {
            height: 100vh; /* ビューポートの高さ全体を使う */
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1; /* オーバーレイボックスより低いz-indexを設定 */
        }

        /* オーバーレイボックスの共通スタイル */
        .overlay-box {
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 8px; /* 角丸 */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            padding: 15px;
            z-index: 1000; /* マップの上に表示 */
            position: absolute;
        }

        /* 情報表示ボックス */
        .info-box {
            top: 20px;
            left: 20px;
            font-size: 14px;
            line-height: 1.8; /* 行間を広げて見やすく */
            display: grid; /* グリッドレイアウトで整列 */
            grid-template-columns: auto 1fr;
            gap: 5px 10px;
            min-width: 280px; /* ある程度の幅を確保 */
        }
        .info-box div {
            white-space: nowrap; /* テキストの折り返しを防ぐ */
        }
        .info-box span {
            font-weight: bold;
            color: #333;
        }

        /* コントロールボックス */
        .control-box {
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px; /* 要素間のスペース */
            padding: 15px;
        }
        .control-box label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        .control-box button,
        .control-box select {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #ccc;
            background-color: #f0f0f0;
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
        }
        .control-box button:hover {
            background-color: #e0e0e0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .control-box button#calibrateButton.calibrating,
        .control-box button#placeSymbolButton.active { /* シンボル配置ボタンのアクティブスタイル */
            background-color: #ff4d4d; /* キャリブレーション中の赤色 */
            color: white;
        }
        .control-box button#calibrateButton.calibrating:hover,
        .control-box button#placeSymbolButton.active:hover {
             background-color: #cc0000;
        }

        /* スライダーボックス */
        .slider-box {
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 250px;
            padding: 15px;
        }
        .slider-box input[type="range"] {
            width: 100%;
            -webkit-appearance: none; /* デフォルトスタイルをリセット */
            height: 8px;
            background: #d3d3d3;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
            border-radius: 4px;
        }
        .slider-box input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #007bff;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .slider-box input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #007bff;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* グラフコンテナ */
        #graph-container {
            bottom: 20px;
            left: 20px;
            width: 450px; /* グラフの幅 */
            height: 280px; /* グラフの高さ */
            padding: 15px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        #graph-container h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #333;
        }
        #azimuthChart {
            width: 100% !important; /* 親要素の幅に合わせる */
            height: 100% !important; /* 親要素の高さに合わせる */
        }

        /* NMEA表示コンテナ */
        #nmea-container {
            position: absolute;
            top: 20px; /* 上部情報ボックスの隣 */
            left: 330px; /* info-boxの幅+余白 */
            width: 500px; /* 適切な幅に調整 */
            height: 280px; /* 適切な高さに調整 */
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            padding: 15px;
            z-index: 1000;
            display: none; /* 初期状態では非表示 */
            flex-direction: column;
        }
        #nmea-output {
            width: 100%;
            height: 100%;
            border: 1px solid #ccc;
            background-color: #f9f9f9;
            font-family: 'Monaco', 'Consolas', monospace; /* 等幅フォント */
            font-size: 12px;
            resize: none; /* リサイズ不可 */
            overflow-y: scroll; /* 縦スクロール */
            padding: 5px;
            box-sizing: border-box; /* paddingを含めて幅計算 */
        }
        #nmea-toggle-button {
            margin-top: 10px;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #ccc;
            background-color: #f0f0f0;
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
        }
        #nmea-toggle-button:hover {
            background-color: #e0e0e0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* カスタムシンボル用のスタイル */
        .custom-symbol-icon {
            background-color: #007bff; /* 青色の円 */
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 0 2px #007bff; /* 外側の光彩 */
        }
        
        /* シンボル情報コンテナ */
        #symbol-info-container {
            position: absolute;
            top: 320px; /* info-boxの下に配置 (info-box height + padding + margin) */
            left: 20px;
            width: 280px; /* info-boxと同じ幅に合わせる */
            height: calc(100vh - 360px); /* 下のグラフを考慮して調整 */
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            padding: 15px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            overflow-y: auto; /* シンボルが増えたらスクロール */
        }
        #symbol-info-container h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #333;
        }
        .symbol-list {
            list-style: none;
            padding: 0;
            margin: 0;
            width: 100%;
        }
        .symbol-item {
            background-color: #f9f9f9;
            border: 1px solid #eee;
            border-radius: 6px;
            padding: 8px 10px;
            margin-bottom: 8px;
            font-size: 13px;
            line-height: 1.5;
            word-wrap: break-word; /* 長いテキストの折り返し */
            position: relative; /* 削除ボタンの配置のため */
        }
        .symbol-item:last-child {
            margin-bottom: 0;
        }
        .symbol-item strong {
            color: #0056b3;
        }
        .delete-symbol-button {
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: #dc3545; /* 赤色 */
            color: white;
            border: none;
            border-radius: 4px;
            padding: 3px 6px;
            font-size: 10px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .delete-symbol-button:hover {
            background-color: #c82333;
        }


        /* 接続ステータス表示用のスタイル */
        .status-ok { color: green; font-weight: bold; }
        .status-ng { color: red; font-weight: bold; }
        #status-message {
            margin-top: 10px;
            font-size: 15px;
            word-break: break-all; /* 長いメッセージの折り返し */
        }

        /* レスポンシブデザイン */
        @media (max-width: 1200px) { /* 画面幅が狭い場合のNMEAコンテナ配置調整 */
            #nmea-container {
                top: auto;
                bottom: 20px;
                left: 500px; /* graph-containerの右隣 */
                width: calc(100% - 520px); /* 右側の余白を考慮 */
                height: 280px;
            }
            #symbol-info-container { /* グラフの下に配置 */
                top: auto;
                bottom: 320px; /* graph-containerの上 */
                left: 20px;
                width: 450px; /* グラフと同じ幅 */
                height: 200px; /* 高さを調整 */
            }
        }
        @media (max-width: 768px) {
            .info-box, .control-box, .slider-box, #graph-container, #nmea-container, #symbol-info-container {
                position: relative; /* 小さい画面では相対配置に */
                width: calc(100% - 40px); /* 左右の余白を考慮 */
                left: 20px;
                right: 20px;
                margin-bottom: 20px;
                top: auto; /* 上下位置のリセット */
            }
            .info-box {
                margin-top: 20px; /* 上部に余白 */
            }
            .control-box {
                flex-direction: column; /* 縦並びに変更 */
            }
            #map {
                height: 50vh; /* 地図の高さを調整 */
                position: relative;
            }
            body {
                overflow-y: auto; /* スクロールを許可 */
            }
            #nmea-container { /* 小さい画面ではinfo-boxの下に配置 */
                left: 20px;
                height: 200px; /* 高さを調整 */
            }
            #symbol-info-container {
                left: 20px;
                height: 200px;
            }
        }
    </style>
</head>
<body>
    <!-- リアルタイム情報表示ボックス -->
    <div class="info-box overlay-box">
        <div>緯度: <span id="baseLat">--</span></div>
        <div>経度: <span id="baseLon">--</span></div>
        <div>HDOP（基準局）: <span id="hdopBase">--</span></div>
        <div>HDOP（移動局）: <span id="hdopRover">--</span></div>
        <div>品質（基準局）: <span id="qualityBase">--</span></div>
        <div>品質（移動局）: <span id="qualityRover">--</span></div>
        <div>方位角（融合）: <span id="headingFused">--</span>°</div>
        <div>方位角（GPS）: <span id="headingGPS">--</span>°</div>
        <div>方位角ずれ: <span id="headingDiff">--</span>°</div>
        <div>基線長: <span id="distance">--</span> m</div>
        <div>基線誤差: <span id="error">--</span> m</div>
        <div>IMU使用: <span id="imuStatus">--</span></div>
        <div>IMU Z軸角速度: <span id="imuRawGyroZ">--</span> °/s</div>
        <div>ジャイロZオフセット: <span id="gyroZOffset">--</span> °/s</div>
        <div id="baseConnected">基準局接続: <span class="status-ng">切断</span></div>
        <div id="roverConnected">移動局接続: <span class="status-ng">切断</span></div>
        <div>基準局ポートエラー: <span id="basePortErrors">0</span></div>
        <div>基準局シリアルエラー: <span id="baseSerialErrors">0</span></div>
        <div>移動局ポートエラー: <span id="roverPortErrors">0</span></div>
        <div>移動局シリアルエラー: <span id="roverSerialErrors">0</span></div>
        <div>ダミーモード: <span id="dummyMode">--</span></div>
        <div>ログレベル: <span id="logLevel">--</span></div>
        <div id="status-message" style="color: blue; font-weight: bold; grid-column: 1 / span 2;"></div>
    </div>

    <!-- コントロールボックス -->
    <div class="control-box overlay-box">
        <label>
            <input type="checkbox" id="followMapCheckbox" checked aria-label="地図追従を有効にする">
            地図追従
        </label>
        <label>
            <input type="checkbox" id="gridCheckbox" checked aria-label="グリッド線を表示する">
            グリッド線表示
        </label>
        <label for="coordSystemSelect">座標系:</label>
        <select id="coordSystemSelect" aria-label="座標系の選択">
            <option value="wgs84">緯度経度</option>
            <option value="utm">UTM</option>
            <option value="jgd2011">平面直角座標</option>
        </select>
        <button id="calibrateButton">IMUキャリブレーション開始</button>
        <label for="logLevelSelect">ログレベル:</label>
        <select id="logLevelSelect" aria-label="ログレベル選択">
            <option value="DEBUG">DEBUG</option>
            <option value="INFO" selected>INFO</option>
            <option value="WARNING">WARNING</option>
            <option value="ERROR">ERROR</option>
            <option value="CRITICAL">CRITICAL</option>
        </select>
        <button id="setLogLevelButton">ログレベル設定</button>
        <button id="nmeaToggleButton">NMEA表示 ON/OFF</button>
        <button id="placeSymbolButton">シンボル配置</button>
    </div>

    <!-- スライダーボックス -->
    <div class="slider-box overlay-box">
        <label for="fanSlider">角度幅: <span id="fanValue">45</span>°</label><br>
        <input type="range" id="fanSlider" min="0" max="90" value="45" aria-label="扇形の角度を調整">
    </div>

    <!-- グラフコンテナ -->
    <div id="graph-container" class="overlay-box">
        <h3>IMU Z軸安定度 (方位角別)</h3>
        <canvas id="azimuthChart"></canvas>
    </div>

    <!-- NMEA表示コンテナ -->
    <div id="nmea-container" class="overlay-box">
        <h3>NMEAデータ</h3>
        <textarea id="nmea-output" readonly></textarea>
    </div>

    <!-- シンボル情報コンテナ -->
    <div id="symbol-info-container" class="overlay-box">
        <h3>配置済みシンボル情報</h3>
        <ul id="symbol-list" class="symbol-list">
            <!-- シンボル情報がここに動的に追加されます -->
        </ul>
    </div>

    <!-- 地図コンテナ -->
    <div id="map"></div>

    <!-- 外部JavaScriptライブラリ -->
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js" crossorigin=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.7.5/proj4.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.0/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-geometryutil@0.9.1/src/leaflet.geometryutil.js"></script>


    <script>
        // === JavaScript for interaction and data fetching ===
        const API_KEY = "your_api_key_here"; // config.iniのAPI_KEYに合わせて**必ず変更してください！**

        let map;
        let baseMarker, roverMarker, headingLine, fanLayer, calculatedHeadingLine; // calculatedHeadingLineを追加
        let followMap = true;
        let gridLayer;
        let currentCoordSystem = 'wgs84'; // 初期座標系
        let azimuthChart; // Chart.jsインスタンス
        let showNMEA = false; // NMEA表示の状態
        let isPlacingSymbol = false; // シンボル配置モードの状態
        let symbolCounter = 0; // シンボルID用のカウンター
        // customMarkersの要素は { id: string, name: string, lat: number, lon: number, marker: L.Marker, element: HTMLElement } となる
        let customMarkers = []; // 配置されたカスタムマーカーを保存する配列

        let chartData = {
            labels: Array.from({length: 360}, (_, i) => i.toString()), // 0-359
            datasets: [{
                label: 'IMU Z軸安定度', // グラフのラベル
                backgroundColor: 'rgba(75, 192, 192, 0.2)',
                borderColor: 'rgba(75, 192, 192, 1)',
                borderWidth: 1,
                data: Array(360).fill(-50), // app.pyの初期値に合わせて-50
                pointRadius: 0, // 点を表示しない
                hitRadius: 0,
                hoverRadius: 0
            }]
        };

        // 角度の差を-180〜180度の範囲に正規化するヘルパー関数
        function normalizeAngleDifference(angle1, angle2) {
            let diff = angle1 - angle2;
            if (diff > 180) diff -= 360;
            if (diff < -180) diff += 360;
            return diff;
        }

        // --- Map Initialization ---
        function initMap() {
            // 東京駅周辺を初期位置として設定
            const tokyoStationLat = 35.681236;
            const tokyoStationLon = 139.767125;

            map = L.map('map').setView([tokyoStationLat, tokyoStationLon], 18); // 初期位置とズームレベル

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                maxZoom: 19
            }).addTo(map);

            // 基準局と移動局のマーカーを東京駅の初期位置に設定
            baseMarker = L.marker([tokyoStationLat, tokyoStationLon], {title: "基準局"}).addTo(map).bindPopup("基準局").openPopup();
            roverMarker = L.marker([tokyoStationLat, tokyoStationLon], {title: "移動局"}).addTo(map).bindPopup("移動局").openPopup();

            // 方位線と扇形のためのレイヤーグループ
            headingLine = L.polyline([], { color: 'blue', weight: 3, opacity: 0.7 }).addTo(map);
            fanLayer = L.polygon([], { color: 'orange', fillOpacity: 0.3, stroke: false }).addTo(map);

            // 新しく追加された、算出した方位を示す線 (破線の緑色)
            calculatedHeadingLine = L.polyline([], { color: 'green', weight: 3, opacity: 0.7, dashArray: '5, 5' }).addTo(map);

            // グリッド線レイヤー
            gridLayer = L.layerGroup().addTo(map);
            updateGrid(map.getBounds()); // 初期グリッド表示
            map.on('moveend', function() {
                if (document.getElementById('gridCheckbox').checked) {
                    updateGrid(map.getBounds());
                }
            });

            // シンボル配置モード時のマップクリックイベント
            map.on('click', function(e) {
                if (isPlacingSymbol) {
                    const lat = e.latlng.lat;
                    const lon = e.latlng.lng;
                    symbolCounter++;
                    const symbolId = `symbol-${symbolCounter}`;
                    const symbolName = `地点 ${symbolCounter}`;

                    // カスタムアイコンを作成
                    const customIcon = L.divIcon({
                        className: 'custom-symbol-icon',
                        iconSize: [16, 16], // アイコンのサイズ
                        iconAnchor: [8, 8], // アイコンの中心 (アイコンサイズの半分)
                        popupAnchor: [0, -8] // ポップアップのアンカー位置
                    });

                    const marker = L.marker([lat, lon], {icon: customIcon}).addTo(map);
                    marker.bindPopup(`<strong>${symbolName}</strong><br>緯度: ${lat.toFixed(7)}<br>経度: ${lon.toFixed(7)}`).openPopup();
                    
                    // シンボル情報表示リストに要素を追加
                    const symbolList = document.getElementById('symbol-list');
                    const listItem = document.createElement('li');
                    listItem.id = `symbol-item-${symbolId}`;
                    listItem.className = 'symbol-item';
                    listItem.innerHTML = `
                        <strong>${symbolName}</strong> 
                        <button class="delete-symbol-button" data-symbol-id="${symbolId}">削除</button><br>
                        緯度: ${lat.toFixed(7)}<br>
                        経度: ${lon.toFixed(7)}<br>
                        基準局からの距離: <span id="dist-${symbolId}">--</span> m<br>
                        基準局からの方位角: <span id="bearing-${symbolId}">--</span> °
                    `;
                    symbolList.appendChild(listItem);

                    // 削除ボタンにイベントリスナーを追加
                    listItem.querySelector('.delete-symbol-button').addEventListener('click', (event) => {
                        const idToDelete = event.target.dataset.symbolId;
                        deleteSymbol(idToDelete);
                    });

                    customMarkers.push({
                        id: symbolId,
                        name: symbolName,
                        lat: lat,
                        lon: lon,
                        marker: marker,
                        element: listItem // HTML要素への参照を保存
                    });
                    console.log(`シンボルを配置しました: ${symbolName} (緯度 ${lat.toFixed(7)}, 経度 ${lon.toFixed(7)})`);
                }
            });
        }

        // --- Function to delete a symbol ---
        function deleteSymbol(symbolId) {
            // customMarkers配列から該当するシンボルを探す
            const index = customMarkers.findIndex(s => s.id === symbolId);
            if (index > -1) {
                const symbolToDelete = customMarkers[index];

                // マップからマーカーを削除
                map.removeLayer(symbolToDelete.marker);

                // DOMからリストアイテムを削除
                symbolToDelete.element.remove();

                // customMarkers配列からシンボルを削除
                customMarkers.splice(index, 1);
                console.log(`シンボル ${symbolId} を削除しました。`);
            }
        }

        // --- Grid Line Functions ---
        function updateGrid(bounds) {
            console.log("updateGrid called with bounds:", bounds.toBBoxString()); // デバッグログ
            gridLayer.clearLayers();
            if (!document.getElementById('gridCheckbox').checked) return;

            // 現在のズームレベルに基づいてグリッド間隔を調整
            const zoom = map.getZoom();
            let intervalLat = 0.01; // デフォルト 0.01度 (約1km)
            let intervalLon = 0.01;

            if (zoom >= 17) {
                intervalLat = 0.001; // 0.001度 (約100m)
                intervalLon = 0.001;
            } else if (zoom >= 15) {
                intervalLat = 0.005; // 0.005度 (約500m)
                intervalLon = 0.005;
            } else if (zoom >= 13) {
                intervalLat = 0.01; // 0.01度 (約1km)
                intervalLon = 0.01;
            } else {
                intervalLat = 0.05; // 0.05度 (約5km)
                intervalLon = 0.05;
            }

            const latMin = Math.floor(bounds.getSouthWest().lat / intervalLat) * intervalLat;
            const latMax = Math.ceil(bounds.getNorthEast().lat / intervalLat) * intervalLat;
            const lonMin = Math.floor(bounds.getSouthWest().lng / intervalLon) * intervalLon;
            const lonMax = Math.ceil(bounds.getNorthEast().lng / intervalLon) * intervalLon;

            // グリッド線のスタイルを元の設定に戻します
            for (let lat = latMin; lat <= latMax; lat += intervalLat) {
                L.polyline([[lat, lonMin], [lat, lonMax]], { color: '#ccc', weight: 0.5, opacity: 0.6, dashArray: '2, 4' }).addTo(gridLayer);
            }
            for (let lon = lonMin; lon <= lonMax; lon += intervalLon) {
                L.polyline([[latMin, lon], [latMax, lon]], { color: '#ccc', weight: 0.5, opacity: 0.6, dashArray: '2, 4' }).addTo(gridLayer);
            }
        }

        // --- Coordinate Transformation Functions ---
        // UTM (Zone 54N for Tokyo)
        proj4.defs("EPSG:32654", "+proj=utm +zone=54 +datum=WGS84 +units=m +no_defs");
        // 平面直角座標系 (JGD2011, 系9 for Kanto)
        // 参照: https://vldb.gsi.go.jp/sokuchi/survey00/densan/calc-kyori.htm
        proj4.defs("JGD2011_PLANE_9", "+proj=tmerc +lat_0=36 +lon_0=139.8333333333333 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");

        function convertCoordinates(lat, lon, targetSystem) {
            if (targetSystem === 'wgs84') {
                return { lat, lon, text: `緯度: ${lat.toFixed(7)}, 経度: ${lon.toFixed(7)}` };
            } else if (targetSystem === 'utm') {
                if (typeof proj4 === 'undefined') {
                    console.error("proj4.jsがロードされていません。UTM変換は利用できません。");
                    return { lat, lon, text: `緯度: ${lat.toFixed(7)}, 経度: ${lon.toFixed(7)} (UTM変換エラー)` };
                }
                const utm = proj4("EPSG:4326", "EPSG:32654", [lon, lat]);
                return { x: utm[0], y: utm[1], text: `UTM-X: ${utm[0].toFixed(2)}, UTM-Y: ${utm[1].toFixed(2)}` };
            } else if (targetSystem === 'jgd2011') {
                 if (typeof proj4 === 'undefined') {
                    console.error("proj4.jsがロードされていません。JGD2011変換は利用できません。");
                    return { lat, lon, text: `緯度: ${lat.toFixed(7)}, 経度: ${lon.toFixed(7)} (JGD2011変換エラー)` };
                }
                const jgd = proj4("EPSG:4326", "JGD2011_PLANE_9", [lon, lat]);
                return { x: jgd[0], y: jgd[1], text: `X: ${jgd[0].toFixed(2)}, Y: ${jgd[1].toFixed(2)} (系9)` };
            }
            return { lat, lon, text: `緯度: ${lat.toFixed(7)}, 経度: ${lon.toFixed(7)}` }; // Fallback
        }

        // --- Chart.js Initialization ---
        function initChart() {
            const ctx = document.getElementById('azimuthChart').getContext('2d');
            azimuthChart = new Chart(ctx, {
                type: 'line',
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: false,
                            min: -99, // app.py のグラフ値の範囲に合わせて調整
                            max: -20, // app.py のグラフ値の範囲に合わせて調整
                            title: {
                                display: true,
                                text: '安定度 (高ほど安定)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: '方位角 (°)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: true,
                            text: 'IMU Z軸安定度 (方位角別)'
                        }
                    },
                    animation: {
                        duration: 0 // アニメーションなしで即時更新
                    }
                }
            });
        }

        // --- Data Fetching and UI Update ---
        async function fetchSensorData() {
            try {
                // 絶対URLを使用
                const response = await fetch(window.location.origin + '/api/position', {
                    headers: { 'X-API-KEY': API_KEY }
                });
                if (!response.ok) {
                    // HTTPエラーレスポンスを検出
                    const errorStatus = response.status;
                    const errorText = await response.text(); // エラーレスポンスボディも取得
                    let errorMessage = `HTTPエラー: ${errorStatus} - ${errorText}`;
                    if (errorStatus === 401) {
                        errorMessage = "認証エラー: APIキーが不正です。";
                    } else if (errorStatus === 404) {
                        errorMessage = "APIエンドポイントが見つかりません (HTTP 404)。バックエンドサーバーが正しく起動しており、ルートが定義されているか確認してください。";
                    }
                    throw new Error(errorMessage);
                }
                const data = await response.json();

                // GPSデータの更新
                const baseLat = data.lat;
                const baseLon = data.lon;
                const roverLat = data.rover_lat;
                const roverLon = data.rover_lon; 

                baseMarker.setLatLng([baseLat, baseLon]);
                roverMarker.setLatLng([roverLat, roverLon]);

                // 方位線の更新 (基準局と移動局を結ぶ線 - 青色)
                const linePoints = [[baseLat, baseLon], [roverLat, roverLon]];
                headingLine.setLatLngs(linePoints);

                // 扇形の更新
                const fanValue = parseFloat(document.getElementById('fanSlider').value);
                const headingFused = data.heading; // 融合方位角
                // L.GeometryUtil.destination を使うため、Leaflet.GeometryUtilのCDNが必要
                if (typeof L.GeometryUtil !== 'undefined' && L.GeometryUtil.destination) {
                    updateFan(roverLat, roverLon, headingFused, fanValue);
                } else {
                    console.warn("L.GeometryUtil.destination が利用できないため、扇形は描画されません。");
                }

                // 算出した方位を示す線の更新 (画面サイズの30%の長さで表示 - 緑色破線)
                if (typeof L.GeometryUtil !== 'undefined' && L.GeometryUtil.destination) {
                    const baseLatLngForCalculatedLine = L.latLng(baseLat, baseLon);
                    const bounds = map.getBounds();
                    // map.distanceは緯度経度からメートル単位の距離を計算
                    const visibleHeightMeters = map.distance(bounds.getNorthWest(), L.latLng(bounds.getSouthWest().lat, bounds.getNorthWest().lng));
                    const visibleWidthMeters = map.distance(bounds.getNorthWest(), bounds.getNorthEast());

                    // 可視領域の短い方の辺の30%を線の長さとする
                    const dynamicLineLengthMeters = Math.min(visibleHeightMeters, visibleWidthMeters) * 0.30;
                    
                    const calculatedLineDestination = L.GeometryUtil.destination(baseLatLngForCalculatedLine, headingFused, dynamicLineLengthMeters);
                    calculatedHeadingLine.setLatLngs([baseLatLngForCalculatedLine, calculatedLineDestination]);
                }


                // 地図の追従
                if (followMap) {
                    map.setView([baseLat, baseLon], map.getZoom());
                }

                // Info Boxの更新
                const convertedBase = convertCoordinates(baseLat, baseLon, currentCoordSystem);
                const convertedRover = convertCoordinates(roverLat, roverLon, currentCoordSystem);

                // `split(',')[0]` は最初のラベル部分を取り出すため
                document.getElementById('baseLat').textContent = convertedBase.text.split(',')[0].split(': ')[1] || convertedBase.text;
                document.getElementById('baseLon').textContent = convertedBase.text.split(',')[1] ? convertedBase.text.split(',')[1].split(': ')[1] : '';
                document.getElementById('hdopBase').textContent = data.hdop_base;
                document.getElementById('hdopRover').textContent = data.hdop_rover;
                document.getElementById('qualityBase').textContent = data.base_quality;
                document.getElementById('qualityRover').textContent = data.rover_quality;
                document.getElementById('headingFused').textContent = data.heading.toFixed(2); // 融合方位角
                document.getElementById('headingGPS').textContent = data.heading_gps.toFixed(2); // GPS方位角
                
                // 方位角のずれ量の計算と表示
                const headingDiff = normalizeAngleDifference(data.heading, data.heading_gps);
                document.getElementById('headingDiff').textContent = headingDiff.toFixed(2);


                document.getElementById('distance').textContent = data.distance.toFixed(3);
                document.getElementById('error').textContent = data.error.toFixed(3);
                
                document.getElementById('imuStatus').textContent = data.imu ? 'ON' : 'OFF';
                document.getElementById('imuStatus').className = data.imu ? 'status-ok' : 'status-ng';

                document.getElementById('imuRawGyroZ').textContent = data.imu_raw_gyro_z.toFixed(5);
                document.getElementById('gyroZOffset').textContent = data.gyro_z_offset.toFixed(5);
                
                document.getElementById('baseConnected').querySelector('span').className = data.base_connected ? 'status-ok' : 'status-ng';
                document.getElementById('baseConnected').querySelector('span').textContent = data.base_connected ? '接続中' : '切断';
                
                document.getElementById('roverConnected').querySelector('span').className = data.rover_connected ? 'status-ok' : 'status-ng';
                document.getElementById('roverConnected').querySelector('span').textContent = data.rover_connected ? '接続中' : '切断';
                
                document.getElementById('basePortErrors').textContent = data.base_port_errors;
                document.getElementById('baseSerialErrors').textContent = data.base_serial_errors;
                document.getElementById('roverPortErrors').textContent = data.rover_port_errors;
                document.getElementById('roverSerialErrors').textContent = data.rover_serial_errors;

                document.getElementById('dummyMode').querySelector('span').textContent = data.dummy_mode ? 'ON' : 'OFF';
                document.getElementById('logLevel').querySelector('span').textContent = data.log_level;

                document.getElementById('status-message').textContent = ""; // エラーメッセージをクリア (成功時)

                // シンボルリストの情報を更新
                if (typeof L.GeometryUtil !== 'undefined' && L.GeometryUtil.distance && L.GeometryUtil.bearing) {
                    const baseLatLng = L.latLng(baseLat, baseLon);
                    customMarkers.forEach(symbol => {
                        const symbolLatLng = L.latLng(symbol.lat, symbol.lon);
                        const distanceToBase = L.GeometryUtil.distance(baseLatLng, symbolLatLng);
                        const bearingToBase = L.GeometryUtil.bearing(baseLatLng, symbolLatLng); // 基準局からシンボルへの方位角

                        document.getElementById(`dist-${symbol.id}`).textContent = distanceToBase.toFixed(3);
                        document.getElementById(`bearing-${symbol.id}`).textContent = bearingToBase.toFixed(2);
                    });
                } else {
                    console.warn("L.GeometryUtilが利用できないため、シンボル情報の距離・方位角は更新されません。");
                }


            } catch (error) {
                console.error("センサーデータの取得中にエラー:", error);
                const statusMessageElement = document.getElementById('status-message');
                let message = `エラー: ${error.message}`;
                let color = 'orange';

                // Failed to fetch (サーバーに接続できない場合)
                if (error instanceof TypeError && error.message.includes("Failed to fetch")) {
                    message = `サーバーに接続できません。バックエンドが実行中か、ネットワーク接続を確認してください。`;
                    color = 'red';
                } else if (error.message.includes("HTTPエラー: 404")) {
                    message = `APIエンドポイントが見つかりません (HTTP 404)。バックエンドサーバーが正しく起動しており、ルートが定義されているか確認してください。`;
                    color = 'red';
                } else if (error.message.includes("認証エラー") || error.message.includes("HTTPエラー: 401")) {
                    message = `認証エラー (HTTP 401): APIキーが不正です。index.htmlとconfig.iniのAPI_KEYが一致しているか確認してください。`;
                    color = 'red';
                }
                
                statusMessageElement.textContent = message;
                statusMessageElement.style.color = color;
            }
        }

        async function fetchGraphData() {
            try {
                // 絶対URLを使用
                const response = await fetch(window.location.origin + '/api/graph_data', {
                    headers: { 'X-API-KEY': API_KEY }
                });
                if (!response.ok) {
                    // HTTPエラーレスポンスを検出
                    const errorStatus = response.status;
                    const errorText = await response.text(); // エラーレスポンスボディも取得
                    let errorMessage = `HTTPエラー: ${errorStatus} - ${errorText}`;
                    if (errorStatus === 401) {
                        errorMessage = "認証エラー: APIキーが不正です。";
                    } else if (errorStatus === 404) {
                        errorMessage = "APIエンドポイントが見つかりません (HTTP 404)。バックエンドサーバーが正しく起動しており、ルートが定義されているか確認してください。";
                    }
                    throw new Error(errorMessage);
                }
                const data = await response.json();
                chartData.datasets[0].data = data.values;
                azimuthChart.update(); // グラフを更新
            } catch (error) {
                console.error("グラフデータの取得中にエラー:", error);
                const statusMessageElement = document.getElementById('status-message');
                let message = `グラフデータの取得中にエラー: ${error.message}`;
                let color = 'orange';

                if (error instanceof TypeError && error.message.includes("Failed to fetch")) {
                    message = `サーバーに接続できません。バックエンドが実行中か、ネットワーク接続を確認してください。`;
                    color = 'red';
                } else if (error.message.includes("HTTPエラー: 404")) {
                    message = `APIエンドポイントが見つかりません (HTTP 404)。バックエンドサーバーが正しく起動しており、ルートが定義されているか確認してください。`;
                    color = 'red';
                } else if (error.message.includes("認証エラー") || error.message.includes("HTTPエラー: 401")) {
                    message = `認証エラー (HTTP 401): APIキーが不正です。index.htmlとconfig.iniのAPI_KEYが一致しているか確認してください。`;
                    color = 'red';
                }

                statusMessageElement.textContent = message;
                statusMessageElement.style.color = color;
            }
        }

        async function fetchNMEAData() {
            if (!showNMEA) return; // 表示がOFFなら何もしない
            try {
                const response = await fetch(window.location.origin + '/api/nmea_data', {
                    headers: { 'X-API-KEY': API_KEY }
                });
                if (!response.ok) {
                    // HTTPエラーレスポンスを検出
                    const errorStatus = response.status;
                    const errorText = await response.text(); // エラーレスポンスボディも取得
                    let errorMessage = `HTTPエラー: ${errorStatus} - ${errorText}`;
                    if (errorStatus === 401) {
                        errorMessage = "認証エラー: APIキーが不正です。";
                    } else if (errorStatus === 404) {
                        errorMessage = "APIエンドポイントが見つかりません (HTTP 404)。バックエンドサーバーが正しく起動しており、ルートが定義されているか確認してください。";
                    }
                    throw new Error(errorMessage);
                }
                const data = await response.json();
                const nmeaOutput = document.getElementById('nmea-output');
                nmeaOutput.value = data.nmea_lines.join('\n'); // 配列を行ごとに結合
                nmeaOutput.scrollTop = nmeaOutput.scrollHeight; // 最下部にスクロール
            } catch (error) {
                console.error("NMEAデータの取得中にエラー:", error);
                const statusMessageElement = document.getElementById('status-message');
                let message = `NMEAデータの取得中にエラー: ${error.message}`;
                let color = 'orange';

                if (error instanceof TypeError && error.message.includes("Failed to fetch")) {
                    message = `サーバーに接続できません。バックエンドが実行中か、ネットワーク接続を確認してください。`;
                    color = 'red';
                } else if (error.message.includes("HTTPエラー: 404")) {
                    message = `APIエンドポイントが見つかりません (HTTP 404)。バックエンドサーバーが正しく起動しており、ルートが定義されているか確認してください。`;
                    color = 'red';
                } else if (error.message.includes("認証エラー") || error.message.includes("HTTPエラー: 401")) {
                    message = `認証エラー (HTTP 401): APIキーが不正です。index.htmlとconfig.iniのAPI_KEYが一致しているか確認してください。`;
                    color = 'red';
                }

                statusMessageElement.textContent = message;
                statusMessageElement.style.color = color;
            }
        }


        // --- Fan Shape (Sector) Update ---
        function updateFan(lat, lon, heading, angleWidth) {
            // 方位角 (heading) は北を0°として時計回り (0-360)
            // angleWidth は扇形の中心から左右への角度 (例えば45°なら全体で90°)
            // Leaflet.GeometryUtil.destination を使用

            const center = L.latLng(lat, lon);
            // 扇形の半径をメートル単位で指定 (例: 50メートル)
            const radiusMeters = 50; 

            const points = [center];
            const startAngle = (heading - angleWidth / 2 + 360) % 360;
            const endAngle = (heading + angleWidth / 2 + 360) % 360;

            const numSegments = 30; // 扇形を構成するセグメント数
            for (let i = 0; i <= numSegments; i++) {
                const angle = startAngle + (endAngle - startAngle) * i / numSegments;
                // L.GeometryUtil.destination(origin, bearing, distance)
                const point = L.GeometryUtil.destination(center, angle, radiusMeters);
                points.push(point);
            }
            points.push(center); // 閉じたポリゴンにするために中心に戻る

            fanLayer.setLatLngs(points);
        }

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            initChart(); // Chart.jsの初期化
            setInterval(fetchSensorData, 1000); // 1秒ごとにデータ更新
            setInterval(fetchGraphData, 5000); // 5秒ごとにグラフデータ更新
            setInterval(fetchNMEAData, 500); // 0.5秒ごとにNMEAデータ更新 (高頻度)

            document.getElementById('followMapCheckbox').addEventListener('change', (e) => {
                followMap = e.target.checked;
            });

            document.getElementById('gridCheckbox').addEventListener('change', (e) => {
                if (e.target.checked) {
                    updateGrid(map.getBounds());
                } else {
                    gridLayer.clearLayers();
                }
            });

            document.getElementById('coordSystemSelect').addEventListener('change', (e) => {
                currentCoordSystem = e.target.value;
                fetchSensorData(); // 座標系が変更されたら表示を更新するために、すぐにデータ取得をトリガー
            });

            document.getElementById('calibrateButton').addEventListener('click', async () => {
                const button = document.getElementById('calibrateButton');
                let action = '';
                if (button.classList.contains('calibrating')) {
                    action = 'stop';
                    button.classList.remove('calibrating');
                    button.textContent = 'IMUキャリブレーション開始';
                } else {
                    action = 'start';
                    button.classList.add('calibrating');
                    button.textContent = 'キャリブレーション停止';
                }
                
                try {
                    // 絶対URLを使用
                    const response = await fetch(window.location.origin + '/api/calibrate_imu', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-API-KEY': API_KEY
                        },
                        body: JSON.stringify({ action: action })
                    });
                    if (!response.ok) {
                        const errorStatus = response.status;
                        const errorText = await response.text();
                        let errorMessage = `HTTPエラー: ${errorStatus} - ${errorText}`;
                        if (errorStatus === 401) {
                            errorMessage = "認証エラー: APIキーが不正です。";
                        } else if (errorStatus === 404) {
                            errorMessage = "APIエンドポイントが見つかりません (HTTP 404)。";
                        }
                        throw new Error(errorMessage);
                    }
                    const result = await response.json();
                    document.getElementById('status-message').textContent = `キャリブレーション: ${result.status}`;
                    if (result.offset !== undefined) {
                        document.getElementById('status-message').textContent += ` オフセット: ${result.offset.toFixed(5)}`;
                    }
                    document.getElementById('status-message').style.color = 'blue'; // 成功時は青色
                } catch (error) {
                    console.error("キャリブレーションAPIエラー:", error);
                    document.getElementById('status-message').textContent = `キャリブレーションエラー: ${error.message}`;
                    document.getElementById('status-message').style.color = 'red'; // エラー時は赤色
                    // エラー時は元の状態に戻す
                    if (action === 'start') {
                        button.classList.remove('calibrating');
                        button.textContent = 'IMUキャリブレーション開始';
                    } else {
                        button.classList.add('calibrating');
                        button.textContent = 'キャリブレーション停止';
                    }
                }
            });

            document.getElementById('setLogLevelButton').addEventListener('click', async () => {
                const logLevel = document.getElementById('logLevelSelect').value;
                try {
                    // 絶対URLを使用
                    const response = await fetch(window.location.origin + '/api/set_log_level', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-API-KEY': API_KEY
                        },
                        body: JSON.stringify({ level: logLevel })
                    });
                    if (!response.ok) {
                        const errorStatus = response.status;
                        const errorText = await response.text();
                        let errorMessage = `HTTPエラー: ${errorStatus} - ${errorText}`;
                        if (errorStatus === 401) {
                            errorMessage = "認証エラー: APIキーが不正です。";
                        } else if (errorStatus === 404) {
                            errorMessage = "APIエンドポイントが見つかりません (HTTP 404)。";
                        }
                        throw new Error(errorMessage);
                    }
                    const result = await response.json();
                    document.getElementById('status-message').textContent = `ログレベル設定: ${result.status}`;
                    document.getElementById('status-message').style.color = 'blue'; // 成功時は青色
                } catch (error) {
                    console.error("ログレベル設定APIエラー:", error);
                    document.getElementById('status-message').textContent = `ログレベル設定エラー: ${error.message}`;
                    document.getElementById('status-message').style.color = 'red'; // エラー時は赤色
                }
            });

            document.getElementById('fanSlider').addEventListener('input', (e) => {
                document.getElementById('fanValue').textContent = e.target.value;
                // スライダーを動かしたときに、最新のデータを使って扇形を更新
                fetchSensorData(); // 最新のGPSデータを取得し、updateFanを呼び出す
            });

            document.getElementById('nmeaToggleButton').addEventListener('click', () => {
                showNMEA = !showNMEA;
                const nmeaContainer = document.getElementById('nmea-container');
                if (showNMEA) {
                    nmeaContainer.style.display = 'flex'; // flexコンテナとして表示
                    fetchNMEAData(); // 表示開始時に一度データを取得
                } else {
                    nmeaContainer.style.display = 'none';
                }
            });

            document.getElementById('placeSymbolButton').addEventListener('click', () => {
                isPlacingSymbol = !isPlacingSymbol;
                const button = document.getElementById('placeSymbolButton');
                if (isPlacingSymbol) {
                    button.classList.add('active');
                    button.textContent = 'シンボル配置停止';
                    map.getContainer().style.cursor = 'crosshair'; // マップカーソルを十字に変更
                    document.getElementById('status-message').textContent = "シンボル配置モード: ON - 地図をクリックして配置";
                    document.getElementById('status-message').style.color = 'green';
                } else {
                    button.classList.remove('active');
                    button.textContent = 'シンボル配置';
                    map.getContainer().style.cursor = 'grab'; // マップカーソルをデフォルトに戻す
                    document.getElementById('status-message').textContent = "シンボル配置モード: OFF";
                    document.getElementById('status-message').style.color = 'blue';
                }
            });
        });
    </script>
</body>
</html>
